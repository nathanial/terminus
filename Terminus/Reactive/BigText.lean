/-
  Terminus Reactive - BigText Widget
  Large ASCII art text using bitmap fonts.
-/
import Terminus.Reactive.Monad
import Terminus.Reactive.Components
import Reactive

open Reactive Reactive.Host

namespace Terminus.Reactive

/-! ## Big Font Definition

8x8 bitmap font for ASCII characters (public domain, derived from IBM VGA fonts).
-/

/-- Big font definition for pixel-based text rendering. -/
structure BigFont where
  height : Nat
  glyph : Char → Array String
  deriving Inhabited

namespace BigFont

/--
8x8 bitmap font for Unicode U+0000-U+007F.

Source: https://github.com/dhepper/font8x8 (public domain)
- Derived from IBM VGA fonts (public domain).
- Stored with least-significant bit as the leftmost pixel.
-/
private def font8x8_basic : Array (Array UInt8) := #[
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  -- Space (32)
  #[0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],  -- ! (33)
  #[0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  -- " (34)
  #[0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00],  -- # (35)
  #[0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00],  -- $ (36)
  #[0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00],  -- % (37)
  #[0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00],  -- & (38)
  #[0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],  -- ' (39)
  #[0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00],  -- ( (40)
  #[0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00],  -- ) (41)
  #[0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],  -- * (42)
  #[0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00],  -- + (43)
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06],  -- , (44)
  #[0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00],  -- - (45)
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00],  -- . (46)
  #[0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00],  -- / (47)
  #[0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00],  -- 0 (48)
  #[0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00],  -- 1 (49)
  #[0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00],  -- 2 (50)
  #[0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00],  -- 3 (51)
  #[0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00],  -- 4 (52)
  #[0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00],  -- 5 (53)
  #[0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00],  -- 6 (54)
  #[0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00],  -- 7 (55)
  #[0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00],  -- 8 (56)
  #[0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00],  -- 9 (57)
  #[0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00],  -- : (58)
  #[0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06],  -- ; (59)
  #[0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00],  -- < (60)
  #[0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00],  -- = (61)
  #[0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00],  -- > (62)
  #[0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00],  -- ? (63)
  #[0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00],  -- @ (64)
  #[0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00],  -- A (65)
  #[0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00],  -- B (66)
  #[0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00],  -- C (67)
  #[0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00],  -- D (68)
  #[0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00],  -- E (69)
  #[0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00],  -- F (70)
  #[0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00],  -- G (71)
  #[0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00],  -- H (72)
  #[0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],  -- I (73)
  #[0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00],  -- J (74)
  #[0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00],  -- K (75)
  #[0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00],  -- L (76)
  #[0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00],  -- M (77)
  #[0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00],  -- N (78)
  #[0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00],  -- O (79)
  #[0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00],  -- P (80)
  #[0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00],  -- Q (81)
  #[0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00],  -- R (82)
  #[0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00],  -- S (83)
  #[0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],  -- T (84)
  #[0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00],  -- U (85)
  #[0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],  -- V (86)
  #[0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],  -- W (87)
  #[0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00],  -- X (88)
  #[0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00],  -- Y (89)
  #[0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00],  -- Z (90)
  #[0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00],  -- [ (91)
  #[0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00],  -- \ (92)
  #[0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00],  -- ] (93)
  #[0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00],  -- ^ (94)
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],  -- _ (95)
  #[0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],  -- ` (96)
  #[0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00],  -- a (97)
  #[0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00],  -- b (98)
  #[0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00],  -- c (99)
  #[0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00],  -- d (100)
  #[0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00],  -- e (101)
  #[0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00],  -- f (102)
  #[0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F],  -- g (103)
  #[0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00],  -- h (104)
  #[0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],  -- i (105)
  #[0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E],  -- j (106)
  #[0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00],  -- k (107)
  #[0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],  -- l (108)
  #[0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00],  -- m (109)
  #[0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00],  -- n (110)
  #[0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00],  -- o (111)
  #[0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F],  -- p (112)
  #[0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78],  -- q (113)
  #[0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00],  -- r (114)
  #[0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00],  -- s (115)
  #[0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00],  -- t (116)
  #[0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00],  -- u (117)
  #[0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],  -- v (118)
  #[0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00],  -- w (119)
  #[0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00],  -- x (120)
  #[0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F],  -- y (121)
  #[0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00],  -- z (122)
  #[0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00],  -- { (123)
  #[0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00],  -- | (124)
  #[0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00],  -- } (125)
  #[0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  -- ~ (126)
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]   -- DEL (127)
]

private def rowString (row : UInt8) (onChar offChar : Char) : String := Id.run do
  let mut chars : List Char := []
  for bit in [0:8] do
    let mask : UInt8 := UInt8.ofNat (Nat.shiftLeft 1 bit)
    if (row &&& mask) != 0 then
      chars := chars ++ [onChar]
    else
      chars := chars ++ [offChar]
  String.ofList chars

private def glyphFromBytes (bytes : Array UInt8) (onChar offChar : Char) : Array String := Id.run do
  let mut rows := #[]
  for i in [0:bytes.size] do
    rows := rows.push (rowString (bytes.getD i 0) onChar offChar)
  rows

private def fallbackIndex : Nat := '?'.toNat
private def fallbackBytes : Array UInt8 := font8x8_basic.getD fallbackIndex (Array.replicate 8 0)

private def glyphBytes (c : Char) : Array UInt8 :=
  let code := c.toNat
  if code < font8x8_basic.size then
    font8x8_basic.getD code fallbackBytes
  else
    fallbackBytes

/-- Block-style 8x8 font (bitmap). -/
def block (onChar : Char := '█') (offChar : Char := ' ') : BigFont := {
  height := 8
  glyph := fun c => glyphFromBytes (glyphBytes c) onChar offChar
}

/-- Apply slant effect to a glyph by adding increasing left padding. -/
private def slantGlyph (rows : Array String) : Array String := Id.run do
  let maxSlant := (rows.size - 1) / 2
  let firstRow := rows.getD 0 ""
  let baseWidth := firstRow.length
  let totalWidth := baseWidth + maxSlant
  let mut result := #[]
  for i in [0 : rows.size] do
    let slantOffset := i / 2
    let row := rows.getD i ""
    let slanted := String.ofList (List.replicate slantOffset ' ') ++ row
    let slantedLen := slanted.length
    let padded := if slantedLen < totalWidth then
      slanted ++ String.ofList (List.replicate (totalWidth - slantedLen) ' ')
    else
      slanted
    result := result.push padded
  result

/-- Slanted variant of the block font (adds horizontal skew). -/
def slant (onChar : Char := '█') (offChar : Char := ' ') : BigFont := {
  height := (block onChar offChar).height
  glyph := fun c => slantGlyph ((block onChar offChar).glyph c)
}

/-- Check if a character is a "set" pixel (not space) -/
private def isSet (c : Char) : Bool := c != ' '

/-- Get character at index from string, returning ' ' if out of bounds -/
private def getAt (s : String) (idx : Nat) : Char :=
  let chars := s.toList
  chars.getD idx ' '

/-- Downsample a 2x2 pixel block to a single pixel using OR logic. -/
private def shrinkBlock (row0 row1 : String) (col : Nat) (onChar : Char) : Char :=
  let c0 := getAt row0 (col * 2)
  let c1 := getAt row0 (col * 2 + 1)
  let c2 := getAt row1 (col * 2)
  let c3 := getAt row1 (col * 2 + 1)
  if isSet c0 || isSet c1 || isSet c2 || isSet c3 then onChar else ' '

/-- Downsample an 8x8 glyph to 4x4 using 2x2 OR-based downsampling -/
private def shrinkGlyph (rows : Array String) (onChar : Char) : Array String := Id.run do
  let mut result := #[]
  for rowPair in [0:4] do
    let row0 := rows.getD (rowPair * 2) ""
    let row1 := rows.getD (rowPair * 2 + 1) ""
    let mut outRow := ""
    for col in [0:4] do
      outRow := outRow.push (shrinkBlock row0 row1 col onChar)
    result := result.push outRow
  result

/-- Small font derived from the block glyphs by 2x downsampling with OR logic. -/
def small (onChar : Char := '█') (offChar : Char := ' ') : BigFont := {
  height := 4
  glyph := fun c => shrinkGlyph ((block onChar offChar).glyph c) onChar
}

/-- Compute the maximum row width for a glyph. -/
def glyphWidth (font : BigFont) (c : Char) : Nat :=
  (font.glyph c).foldl (fun acc row => max acc row.length) 0

end BigFont

/-! ## BigText Configuration -/

/-- Font type for BigText -/
inductive BigTextFont where
  | block
  | slant
  | small
  deriving Repr, Inhabited, BEq

/-- Configuration for big text widget -/
structure BigTextConfig where
  /-- Font to use -/
  font : BigTextFont := .block
  /-- Style for "on" pixels -/
  style : Style := {}
  /-- Character for "on" pixels -/
  onChar : Char := '█'
  /-- Character for "off" pixels (none = transparent) -/
  offChar : Option Char := none
  /-- Style for "off" pixels -/
  offStyle : Style := {}
  /-- Alignment -/
  alignment : Alignment := .left
  /-- Spacing between characters -/
  spacing : Nat := 1
  deriving Repr, Inhabited

/-! ## BigText Widget -/

/-- Get the BigFont based on config -/
private def getBigFont (config : BigTextConfig) : BigFont :=
  let offChar := config.offChar.getD ' '
  match config.font with
  | .block => BigFont.block config.onChar offChar
  | .slant => BigFont.slant config.onChar offChar
  | .small => BigFont.small config.onChar offChar

/-- Render a single line of big text to RNodes.
    This is useful when you need to build RNodes directly (e.g., in emitDynamic blocks). -/
def renderBigTextLine (text : String) (config : BigTextConfig) : Array RNode := Id.run do
  let font := getBigFont config
  let chars := text.toList

  if chars.isEmpty then return #[]

  -- Build each row
  let mut rows : Array RNode := #[]
  for rowIdx in [0:font.height] do
    let mut rowContent := ""
    let mut isFirst := true
    for c in chars do
      if !isFirst then
        rowContent := rowContent ++ String.ofList (List.replicate config.spacing ' ')
      let glyph := font.glyph c
      let rowStr := glyph.getD rowIdx ""
      rowContent := rowContent ++ rowStr
      isFirst := false

    -- Create row node with styling
    -- For now, just use the on-style for the whole row
    rows := rows.push (RNode.text rowContent config.style)

  rows

/-- Create a big text widget.

    Example:
    ```
    bigText' "HELLO" { font := .block, style := { fg := .ansi .cyan } }
    ```
-/
def bigText' (text : String) (config : BigTextConfig := {}) : WidgetM Unit := do
  emitStatic (RNode.column 0 {} (renderBigTextLine text config))

/-- Create a dynamic big text widget.

    Example:
    ```
    let textDyn ← someTextSource
    dynBigText' textDyn { font := .slant }
    ```
-/
def dynBigText' (text : Reactive.Dynamic Spider String) (config : BigTextConfig := {})
    : WidgetM Unit := do
  let node ← text.map' (fun t =>
    RNode.column 0 {} (renderBigTextLine t config)
  )
  emit node

/-- Create a multi-line big text widget.

    Example:
    ```
    bigTextMultiline' "LINE 1\nLINE 2" { font := .small }
    ```
-/
def bigTextMultiline' (text : String) (config : BigTextConfig := {}) : WidgetM Unit := do
  let lines := text.splitOn "\n"
  let mut allRows : Array RNode := #[]
  for line in lines do
    let lineRows := renderBigTextLine line config
    allRows := allRows ++ lineRows
    -- Add a blank row between lines
    if line != lines.getLast! then
      allRows := allRows.push (RNode.spacer 0 1)
  emitStatic (RNode.column 0 {} allRows)

end Terminus.Reactive
