-- Terminus.Widgets.BigText: Large pixel text widget

import Terminus.Widgets.Widget
import Terminus.Widgets.Block
import Terminus.Widgets.Paragraph

namespace Terminus

/-- Big font definition for pixel-based text rendering. -/
structure BigFont where
  height : Nat
  glyph : Char → Array String
  deriving Inhabited

namespace BigFont

private def arrayFromList {α : Type} (xs : List α) : Array α :=
  xs.foldl (fun acc x => acc.push x) #[]

/--
8x8 bitmap font for Unicode U+0000-U+007F.

Source: https://github.com/dhepper/font8x8 (public domain)
- Derived from IBM VGA fonts (public domain).
- Stored with least-significant bit as the leftmost pixel.
-/
private def font8x8_basic : Array (Array UInt8) := #[
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],
  #[0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00],
  #[0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00],
  #[0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00],
  #[0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00],
  #[0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00],
  #[0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00],
  #[0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
  #[0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06],
  #[0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00],
  #[0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00],
  #[0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00],
  #[0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00],
  #[0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00],
  #[0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00],
  #[0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00],
  #[0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00],
  #[0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00],
  #[0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00],
  #[0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00],
  #[0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00],
  #[0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00],
  #[0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06],
  #[0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00],
  #[0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00],
  #[0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00],
  #[0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00],
  #[0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00],
  #[0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00],
  #[0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00],
  #[0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00],
  #[0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00],
  #[0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00],
  #[0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00],
  #[0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00],
  #[0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00],
  #[0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
  #[0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00],
  #[0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00],
  #[0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00],
  #[0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00],
  #[0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00],
  #[0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00],
  #[0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00],
  #[0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00],
  #[0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00],
  #[0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00],
  #[0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
  #[0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00],
  #[0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],
  #[0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
  #[0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00],
  #[0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00],
  #[0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00],
  #[0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00],
  #[0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00],
  #[0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00],
  #[0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],
  #[0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00],
  #[0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00],
  #[0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00],
  #[0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00],
  #[0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00],
  #[0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00],
  #[0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F],
  #[0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00],
  #[0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
  #[0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E],
  #[0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00],
  #[0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
  #[0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00],
  #[0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00],
  #[0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00],
  #[0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F],
  #[0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78],
  #[0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00],
  #[0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00],
  #[0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00],
  #[0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00],
  #[0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],
  #[0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00],
  #[0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00],
  #[0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F],
  #[0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00],
  #[0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00],
  #[0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00],
  #[0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00],
  #[0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  #[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
]

private def rowString (row : UInt8) : String := Id.run do
  let mut chars : List Char := []
  for bit in [0:8] do
    let mask : UInt8 := UInt8.ofNat (Nat.shiftLeft 1 bit)
    if (row &&& mask) != 0 then
      chars := chars ++ ['#']
    else
      chars := chars ++ [' ']
  String.ofList chars

private def glyphFromBytes (bytes : Array UInt8) : Array String := Id.run do
  let mut rows := #[]
  for i in [0:bytes.size] do
    rows := rows.push (rowString bytes[i]!)
  rows

private def fallbackIndex : Nat := '?'.toNat
private def fallbackBytes : Array UInt8 := font8x8_basic.getD fallbackIndex (Array.replicate 8 0)

private def glyphBytes (c : Char) : Array UInt8 :=
  let code := c.toNat
  if code < font8x8_basic.size then
    font8x8_basic.getD code fallbackBytes
  else
    fallbackBytes

/-- Block-style 8x8 font (bitmap). -/
def block : BigFont := {
  height := 8
  glyph := fun c => glyphFromBytes (glyphBytes c)
}

/-- Apply slant effect to a glyph by adding increasing left padding.
    All rows are padded to the same width (original width + max slant). -/
private def slantGlyph (rows : Array String) : Array String := Id.run do
  let maxSlant := (rows.size - 1) / 2  -- Max offset for last row
  let firstRow := rows.getD 0 ""
  let baseWidth := firstRow.length
  let totalWidth := baseWidth + maxSlant
  let mut result := #[]
  for i in [0 : rows.size] do
    let slantOffset := i / 2
    let row := rows.getD i ""
    -- Add leading spaces for slant, then original row, then trailing spaces
    let slanted := String.ofList (List.replicate slantOffset ' ') ++ row
    -- Pad to consistent width
    let slantedLen := slanted.length
    let padded := if slantedLen < totalWidth then
      slanted ++ String.ofList (List.replicate (totalWidth - slantedLen) ' ')
    else
      slanted
    result := result.push padded
  result

/-- Slanted variant of the block font (adds horizontal skew). -/
def slant : BigFont := {
  height := block.height
  glyph := fun c => slantGlyph (block.glyph c)
}

/-- Check if a character is a "set" pixel (not space) -/
private def isSet (c : Char) : Bool := c != ' '

/-- Get character at index from string, returning ' ' if out of bounds -/
private def getAt (s : String) (idx : Nat) : Char :=
  let chars := s.toList
  chars.getD idx ' '

/-- Downsample a 2x2 pixel block to a single pixel using OR logic.
    If any pixel in the block is set, the result is set. -/
private def shrinkBlock (row0 row1 : String) (col : Nat) : Char :=
  let c0 := getAt row0 (col * 2)
  let c1 := getAt row0 (col * 2 + 1)
  let c2 := getAt row1 (col * 2)
  let c3 := getAt row1 (col * 2 + 1)
  if isSet c0 || isSet c1 || isSet c2 || isSet c3 then '#' else ' '

/-- Downsample an 8x8 glyph to 4x4 using 2x2 OR-based downsampling -/
private def shrinkGlyph (rows : Array String) : Array String := Id.run do
  let mut result := #[]
  -- Process pairs of rows (0-1, 2-3, 4-5, 6-7) to produce 4 output rows
  for rowPair in [0:4] do
    let row0 := rows.getD (rowPair * 2) ""
    let row1 := rows.getD (rowPair * 2 + 1) ""
    let mut outRow := ""
    -- Process pairs of columns to produce 4 output columns
    for col in [0:4] do
      outRow := outRow.push (shrinkBlock row0 row1 col)
    result := result.push outRow
  result

/-- Small font derived from the block glyphs by 2x downsampling with OR logic. -/
def small : BigFont := {
  height := 4
  glyph := fun c => shrinkGlyph (block.glyph c)
}

/-- Compute the maximum row width for a glyph. -/
def glyphWidth (font : BigFont) (c : Char) : Nat :=
  (font.glyph c).foldl (fun acc row => max acc row.length) 0

end BigFont

/-- Big text widget for rendering large pixel fonts. -/
structure BigText where
  text : String
  font : BigFont := BigFont.block
  style : Style := {}
  on : Char := '█'
  off : Option Char := none
  offStyle : Style := {}
  alignment : Alignment := .left
  spacing : Nat := 1
  block : Option Block := none
  deriving Inhabited

namespace BigText

/-- Create a BigText widget from a string. -/
def new (s : String) : BigText := { text := s }

def withFont (b : BigText) (f : BigFont) : BigText := { b with font := f }

def withStyle (b : BigText) (s : Style) : BigText := { b with style := s }

def withOn (b : BigText) (c : Char) : BigText := { b with on := c }

def withOff (b : BigText) (c : Char) : BigText := { b with off := some c }

def transparent (b : BigText) : BigText := { b with off := none }

def withOffStyle (b : BigText) (s : Style) : BigText := { b with offStyle := s }

def withAlignment (b : BigText) (a : Alignment) : BigText := { b with alignment := a }

def withSpacing (b : BigText) (n : Nat) : BigText := { b with spacing := n }

def withBlock (b : BigText) (blk : Block) : BigText := { b with block := some blk }

def centered (b : BigText) : BigText := b.withAlignment .center

def rightAligned (b : BigText) : BigText := b.withAlignment .right

private def alignOffset (textWidth areaWidth : Nat) (align : Alignment) : Nat :=
  match align with
  | .left => 0
  | .center => if areaWidth > textWidth then (areaWidth - textWidth) / 2 else 0
  | .right => if areaWidth > textWidth then areaWidth - textWidth else 0

private def lineWidth (font : BigFont) (line : String) (spacing : Nat) : Nat := Id.run do
  let chars := line.toList
  let totalChars := chars.length
  let mut width := 0
  let mut idx := 0
  for c in chars do
    width := width + BigFont.glyphWidth font c
    if idx + 1 < totalChars then
      width := width + spacing
    idx := idx + 1
  width

end BigText

instance : Widget BigText where
  render b area buf := Id.run do
    let mut result := match b.block with
      | some blk => Widget.render blk area buf
      | none => buf

    let contentArea := match b.block with
      | some blk => blk.innerArea area
      | none => area

    if contentArea.isEmpty || contentArea.height == 0 then return result

    let lines := b.text.splitOn "\n"
    let mut lineIdx := 0

    for line in lines do
      let baseY := contentArea.y + lineIdx * b.font.height
      if baseY >= contentArea.y + contentArea.height then break

      let lineW := BigText.lineWidth b.font line b.spacing
      let xOffset := BigText.alignOffset lineW contentArea.width b.alignment

      for row in [0 : b.font.height] do
        let y := baseY + row
        if y >= contentArea.y + contentArea.height then break

        let mut x := contentArea.x + xOffset
        let chars := line.toList
        let totalChars := chars.length
        let mut idx := 0
        for c in chars do
          let glyph := b.font.glyph c
          let glyphW := BigFont.glyphWidth b.font c
          let rowStr := if row < glyph.size then glyph[row]! else ""

          for ch in rowStr.toList do
            if x >= contentArea.x + contentArea.width then break
            if ch == ' ' then
              match b.off with
              | some offChar =>
                result := result.setStyled x y offChar b.offStyle
              | none =>
                pure ()
            else
              result := result.setStyled x y b.on b.style
            x := x + 1

          if glyphW > rowStr.length then
            x := x + (glyphW - rowStr.length)

          if idx + 1 < totalChars then
            x := x + b.spacing

          if x >= contentArea.x + contentArea.width then break
          idx := idx + 1

      lineIdx := lineIdx + 1

    result

end Terminus
